{"ast":null,"code":"import { ethers, constants } from \"ethers\";\nimport { getMarketPrice, getTokenPrice } from \"../../helpers\";\nimport { calculateUserBondDetails, getBalances } from \"./account-slice\";\nimport { getAddresses } from \"../../constants\";\nimport { fetchPendingTxns, clearPendingTxn } from \"./pending-txns-slice\";\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchAccountSuccess } from \"./account-slice\";\nimport { getBondCalculator } from \"../../helpers/bond-calculator\";\nimport { avaxSb, wavax } from \"../../helpers/bond\";\nimport { error, warning, success, info } from \"../slices/messages-slice\";\nimport { messages } from \"../../constants/messages\";\nimport { getGasPrice } from \"../../helpers/get-gas-price\";\nimport { metamaskErrorWrap } from \"../../helpers/metamask-error-wrap\";\nimport { sleep } from \"../../helpers\";\nimport i18n from \"../../i18n\";\nexport const changeApproval = createAsyncThunk(\"bonding/changeApproval\", async (_ref, _ref2) => {\n  let {\n    bond,\n    provider,\n    networkID,\n    address\n  } = _ref;\n  let {\n    dispatch\n  } = _ref2;\n\n  if (!provider) {\n    dispatch(warning({\n      text: messages.please_connect_wallet\n    }));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const reserveContract = bond.getContractForReserve(networkID, signer);\n  let approveTx;\n\n  try {\n    const gasPrice = await getGasPrice(provider);\n    const bondAddr = bond.getAddressForBond(networkID);\n    approveTx = await reserveContract.approve(bondAddr, constants.MaxUint256, {\n      gasPrice\n    });\n    dispatch(fetchPendingTxns({\n      txnHash: approveTx.hash,\n      text: i18n.t(\"bond:ApprovingBond\", {\n        bond: bond.displayName\n      }),\n      type: \"approve_\" + bond.name\n    }));\n    await approveTx.wait();\n    dispatch(success({\n      text: messages.tx_successfully_send\n    }));\n  } catch (err) {\n    metamaskErrorWrap(err, dispatch);\n  } finally {\n    if (approveTx) {\n      dispatch(clearPendingTxn(approveTx.hash));\n    }\n  }\n\n  await sleep(2);\n  let allowance = \"0\";\n  allowance = await reserveContract.allowance(address, bond.getAddressForBond(networkID));\n  return dispatch(fetchAccountSuccess({\n    bonds: {\n      [bond.name]: {\n        allowance: Number(allowance)\n      }\n    }\n  }));\n});\nexport const calcBondDetails = createAsyncThunk(\"bonding/calcBondDetails\", async (_ref3, _ref4) => {\n  let {\n    bond,\n    value,\n    provider,\n    networkID\n  } = _ref3;\n  let {\n    dispatch\n  } = _ref4;\n\n  if (!value) {\n    value = \"0\";\n  }\n\n  const amountInWei = ethers.utils.parseEther(value);\n  let bondPrice = 0,\n      bondDiscount = 0,\n      valuation = 0,\n      bondQuote = 0;\n  const addresses = getAddresses(networkID);\n  const bondContract = bond.getContractForBond(networkID, provider);\n  const bondCalcContract = getBondCalculator(networkID, provider);\n  const terms = await bondContract.terms();\n  const maxBondPrice = (await bondContract.maxPayout()) / Math.pow(10, 9);\n  let marketPrice = await getMarketPrice(networkID, provider);\n  const mimPrice = getTokenPrice(\"MIM\");\n  marketPrice = marketPrice / Math.pow(10, 9) * mimPrice;\n\n  try {\n    bondPrice = await bondContract.bondPriceInUSD();\n\n    if (bond.name === avaxSb.name) {\n      const avaxPrice = getTokenPrice(\"AVAX\");\n      bondPrice = bondPrice * avaxPrice;\n    }\n\n    bondDiscount = (marketPrice * Math.pow(10, 18) - bondPrice) / bondPrice;\n  } catch (e) {\n    console.log(\"error getting bondPriceInUSD\", e);\n  }\n\n  let maxBondPriceToken = 0;\n  const maxBodValue = ethers.utils.parseEther(\"1\");\n\n  if (bond.isLP) {\n    valuation = await bondCalcContract.valuation(bond.getAddressForReserve(networkID), amountInWei);\n    bondQuote = await bondContract.payoutFor(valuation);\n    bondQuote = bondQuote / Math.pow(10, 9);\n    const maxValuation = await bondCalcContract.valuation(bond.getAddressForReserve(networkID), maxBodValue);\n    const maxBondQuote = await bondContract.payoutFor(maxValuation);\n    maxBondPriceToken = maxBondPrice / (maxBondQuote * Math.pow(10, -9));\n  } else {\n    bondQuote = await bondContract.payoutFor(amountInWei);\n    bondQuote = bondQuote / Math.pow(10, 18);\n    const maxBondQuote = await bondContract.payoutFor(maxBodValue);\n    maxBondPriceToken = maxBondPrice / (maxBondQuote * Math.pow(10, -18));\n  }\n\n  if (!!value && bondQuote > maxBondPrice) {\n    dispatch(error({\n      text: messages.try_mint_more(maxBondPrice.toFixed(2).toString())\n    }));\n  } // Calculate bonds purchased\n\n\n  const token = bond.getContractForReserve(networkID, provider);\n  let purchased = await token.balanceOf(addresses.TREASURY_ADDRESS);\n\n  if (bond.isLP) {\n    const assetAddress = bond.getAddressForReserve(networkID);\n    const markdown = await bondCalcContract.markdown(assetAddress);\n    purchased = await bondCalcContract.valuation(assetAddress, purchased);\n    purchased = markdown / Math.pow(10, 18) * (purchased / Math.pow(10, 9));\n\n    if (bond.name === avaxSb.name) {\n      const avaxPrice = getTokenPrice(\"AVAX\");\n      purchased = purchased * avaxPrice;\n    }\n  } else if (bond.name === wavax.name) {\n    purchased = purchased / Math.pow(10, 18);\n    const avaxPrice = getTokenPrice(\"AVAX\");\n    purchased = purchased * avaxPrice;\n  } else {\n    purchased = purchased / Math.pow(10, 18);\n  }\n\n  return {\n    bond: bond.name,\n    bondDiscount,\n    bondQuote,\n    purchased,\n    vestingTerm: Number(terms.vestingTerm),\n    maxBondPrice,\n    bondPrice: bondPrice / Math.pow(10, 18),\n    marketPrice,\n    maxBondPriceToken\n  };\n});\nexport const bondAsset = createAsyncThunk(\"bonding/bondAsset\", async (_ref5, _ref6) => {\n  let {\n    value,\n    address,\n    bond,\n    networkID,\n    provider,\n    slippage,\n    useAvax\n  } = _ref5;\n  let {\n    dispatch\n  } = _ref6;\n  const depositorAddress = address;\n  const acceptedSlippage = slippage / 100 || 0.005;\n  const valueInWei = ethers.utils.parseUnits(value, \"ether\");\n  const signer = provider.getSigner();\n  const bondContract = bond.getContractForBond(networkID, signer);\n  const calculatePremium = await bondContract.bondPrice();\n  const maxPremium = Math.round(calculatePremium * (1 + acceptedSlippage));\n  let bondTx;\n\n  try {\n    const gasPrice = await getGasPrice(provider);\n\n    if (useAvax) {\n      bondTx = await bondContract.deposit(valueInWei, maxPremium, depositorAddress, {\n        value: valueInWei,\n        gasPrice\n      });\n    } else {\n      bondTx = await bondContract.deposit(valueInWei, maxPremium, depositorAddress, {\n        gasPrice\n      });\n    }\n\n    dispatch(fetchPendingTxns({\n      txnHash: bondTx.hash,\n      text: i18n.t(\"bond:BondingBond\", {\n        bond: bond.displayName\n      }),\n      type: \"bond_\" + bond.name\n    }));\n    await bondTx.wait();\n    dispatch(success({\n      text: messages.tx_successfully_send\n    }));\n    dispatch(info({\n      text: messages.your_balance_update_soon\n    }));\n    await sleep(10);\n    await dispatch(calculateUserBondDetails({\n      address,\n      bond,\n      networkID,\n      provider\n    }));\n    dispatch(info({\n      text: messages.your_balance_updated\n    }));\n    return;\n  } catch (err) {\n    return metamaskErrorWrap(err, dispatch);\n  } finally {\n    if (bondTx) {\n      dispatch(clearPendingTxn(bondTx.hash));\n    }\n  }\n});\nexport const redeemBond = createAsyncThunk(\"bonding/redeemBond\", async (_ref7, _ref8) => {\n  let {\n    address,\n    bond,\n    networkID,\n    provider,\n    autostake\n  } = _ref7;\n  let {\n    dispatch\n  } = _ref8;\n\n  if (!provider) {\n    dispatch(warning({\n      text: messages.please_connect_wallet\n    }));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const bondContract = bond.getContractForBond(networkID, signer);\n  let redeemTx;\n\n  try {\n    const gasPrice = await getGasPrice(provider);\n    redeemTx = await bondContract.redeem(address, autostake === true, {\n      gasPrice\n    });\n    const pendingTxnType = \"redeem_bond_\" + bond.name + (autostake === true ? \"_autostake\" : \"\");\n    dispatch(fetchPendingTxns({\n      txnHash: redeemTx.hash,\n      text: i18n.t(\"bond:RedeemingBond\", {\n        bond: bond.displayName\n      }),\n      type: pendingTxnType\n    }));\n    await redeemTx.wait();\n    dispatch(success({\n      text: messages.tx_successfully_send\n    }));\n    await sleep(0.01);\n    dispatch(info({\n      text: messages.your_balance_update_soon\n    }));\n    await sleep(10);\n    await dispatch(calculateUserBondDetails({\n      address,\n      bond,\n      networkID,\n      provider\n    }));\n    await dispatch(getBalances({\n      address,\n      networkID,\n      provider\n    }));\n    dispatch(info({\n      text: messages.your_balance_updated\n    }));\n    return;\n  } catch (err) {\n    metamaskErrorWrap(err, dispatch);\n  } finally {\n    if (redeemTx) {\n      dispatch(clearPendingTxn(redeemTx.hash));\n    }\n  }\n});\nconst initialState = {\n  loading: true\n};\n\nconst setBondState = (state, payload) => {\n  const bond = payload.bond;\n  const newState = { ...state[bond],\n    ...payload\n  };\n  state[bond] = newState;\n  state.loading = false;\n};\n\nconst bondingSlice = createSlice({\n  name: \"bonding\",\n  initialState,\n  reducers: {\n    fetchBondSuccess(state, action) {\n      state[action.payload.bond] = action.payload;\n    }\n\n  },\n  extraReducers: builder => {\n    builder.addCase(calcBondDetails.pending, state => {\n      state.loading = true;\n    }).addCase(calcBondDetails.fulfilled, (state, action) => {\n      setBondState(state, action.payload);\n      state.loading = false;\n    }).addCase(calcBondDetails.rejected, (state, _ref9) => {\n      let {\n        error\n      } = _ref9;\n      state.loading = false;\n      console.log(error);\n    });\n  }\n});\nexport default bondingSlice.reducer;\nexport const {\n  fetchBondSuccess\n} = bondingSlice.actions;\n\nconst baseInfo = state => state.bonding;\n\nexport const getBondingState = createSelector(baseInfo, bonding => bonding);","map":{"version":3,"sources":["/Users/anthonymann/Desktop/Snowbank DAO/snowbank-frontend/src/store/slices/bond-slice.ts"],"names":["ethers","constants","getMarketPrice","getTokenPrice","calculateUserBondDetails","getBalances","getAddresses","fetchPendingTxns","clearPendingTxn","createSlice","createSelector","createAsyncThunk","fetchAccountSuccess","getBondCalculator","avaxSb","wavax","error","warning","success","info","messages","getGasPrice","metamaskErrorWrap","sleep","i18n","changeApproval","bond","provider","networkID","address","dispatch","text","please_connect_wallet","signer","getSigner","reserveContract","getContractForReserve","approveTx","gasPrice","bondAddr","getAddressForBond","approve","MaxUint256","txnHash","hash","t","displayName","type","name","wait","tx_successfully_send","err","allowance","bonds","Number","calcBondDetails","value","amountInWei","utils","parseEther","bondPrice","bondDiscount","valuation","bondQuote","addresses","bondContract","getContractForBond","bondCalcContract","terms","maxBondPrice","maxPayout","Math","pow","marketPrice","mimPrice","bondPriceInUSD","avaxPrice","e","console","log","maxBondPriceToken","maxBodValue","isLP","getAddressForReserve","payoutFor","maxValuation","maxBondQuote","try_mint_more","toFixed","toString","token","purchased","balanceOf","TREASURY_ADDRESS","assetAddress","markdown","vestingTerm","bondAsset","slippage","useAvax","depositorAddress","acceptedSlippage","valueInWei","parseUnits","calculatePremium","maxPremium","round","bondTx","deposit","your_balance_update_soon","your_balance_updated","redeemBond","autostake","redeemTx","redeem","pendingTxnType","initialState","loading","setBondState","state","payload","newState","bondingSlice","reducers","fetchBondSuccess","action","extraReducers","builder","addCase","pending","fulfilled","rejected","reducer","actions","baseInfo","bonding","getBondingState"],"mappings":"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","sourcesContent":["import { ethers, constants } from \"ethers\";\nimport { getMarketPrice, getTokenPrice } from \"../../helpers\";\nimport { calculateUserBondDetails, getBalances } from \"./account-slice\";\nimport { getAddresses } from \"../../constants\";\nimport { fetchPendingTxns, clearPendingTxn } from \"./pending-txns-slice\";\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { JsonRpcProvider, StaticJsonRpcProvider } from \"@ethersproject/providers\";\nimport { fetchAccountSuccess } from \"./account-slice\";\nimport { Bond } from \"../../helpers/bond/bond\";\nimport { Networks } from \"../../constants/blockchain\";\nimport { getBondCalculator } from \"../../helpers/bond-calculator\";\nimport { RootState } from \"../store\";\nimport { avaxSb, wavax } from \"../../helpers/bond\";\nimport { error, warning, success, info } from \"../slices/messages-slice\";\nimport { messages } from \"../../constants/messages\";\nimport { getGasPrice } from \"../../helpers/get-gas-price\";\nimport { metamaskErrorWrap } from \"../../helpers/metamask-error-wrap\";\nimport { sleep } from \"../../helpers\";\nimport i18n from \"../../i18n\";\n\ninterface IChangeApproval {\n    bond: Bond;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    networkID: Networks;\n    address: string;\n}\n\nexport const changeApproval = createAsyncThunk(\"bonding/changeApproval\", async ({ bond, provider, networkID, address }: IChangeApproval, { dispatch }) => {\n    if (!provider) {\n        dispatch(warning({ text: messages.please_connect_wallet }));\n        return;\n    }\n\n    const signer = provider.getSigner();\n    const reserveContract = bond.getContractForReserve(networkID, signer);\n\n    let approveTx;\n    try {\n        const gasPrice = await getGasPrice(provider);\n        const bondAddr = bond.getAddressForBond(networkID);\n        approveTx = await reserveContract.approve(bondAddr, constants.MaxUint256, { gasPrice });\n        dispatch(\n            fetchPendingTxns({\n                txnHash: approveTx.hash,\n                text: i18n.t(\"bond:ApprovingBond\", { bond: bond.displayName }),\n                type: \"approve_\" + bond.name,\n            }),\n        );\n        await approveTx.wait();\n        dispatch(success({ text: messages.tx_successfully_send }));\n    } catch (err: any) {\n        metamaskErrorWrap(err, dispatch);\n    } finally {\n        if (approveTx) {\n            dispatch(clearPendingTxn(approveTx.hash));\n        }\n    }\n\n    await sleep(2);\n\n    let allowance = \"0\";\n\n    allowance = await reserveContract.allowance(address, bond.getAddressForBond(networkID));\n\n    return dispatch(\n        fetchAccountSuccess({\n            bonds: {\n                [bond.name]: {\n                    allowance: Number(allowance),\n                },\n            },\n        }),\n    );\n});\n\ninterface ICalcBondDetails {\n    bond: Bond;\n    value: string | null;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    networkID: Networks;\n}\n\nexport interface IBondDetails {\n    bond: string;\n    bondDiscount: number;\n    bondQuote: number;\n    purchased: number;\n    vestingTerm: number;\n    maxBondPrice: number;\n    bondPrice: number;\n    marketPrice: number;\n    maxBondPriceToken: number;\n}\n\nexport const calcBondDetails = createAsyncThunk(\"bonding/calcBondDetails\", async ({ bond, value, provider, networkID }: ICalcBondDetails, { dispatch }) => {\n    if (!value) {\n        value = \"0\";\n    }\n\n    const amountInWei = ethers.utils.parseEther(value);\n\n    let bondPrice = 0,\n        bondDiscount = 0,\n        valuation = 0,\n        bondQuote = 0;\n\n    const addresses = getAddresses(networkID);\n\n    const bondContract = bond.getContractForBond(networkID, provider);\n    const bondCalcContract = getBondCalculator(networkID, provider);\n\n    const terms = await bondContract.terms();\n    const maxBondPrice = (await bondContract.maxPayout()) / Math.pow(10, 9);\n\n    let marketPrice = await getMarketPrice(networkID, provider);\n\n    const mimPrice = getTokenPrice(\"MIM\");\n    marketPrice = (marketPrice / Math.pow(10, 9)) * mimPrice;\n\n    try {\n        bondPrice = await bondContract.bondPriceInUSD();\n\n        if (bond.name === avaxSb.name) {\n            const avaxPrice = getTokenPrice(\"AVAX\");\n            bondPrice = bondPrice * avaxPrice;\n        }\n\n        bondDiscount = (marketPrice * Math.pow(10, 18) - bondPrice) / bondPrice;\n    } catch (e) {\n        console.log(\"error getting bondPriceInUSD\", e);\n    }\n\n    let maxBondPriceToken = 0;\n    const maxBodValue = ethers.utils.parseEther(\"1\");\n\n    if (bond.isLP) {\n        valuation = await bondCalcContract.valuation(bond.getAddressForReserve(networkID), amountInWei);\n        bondQuote = await bondContract.payoutFor(valuation);\n        bondQuote = bondQuote / Math.pow(10, 9);\n\n        const maxValuation = await bondCalcContract.valuation(bond.getAddressForReserve(networkID), maxBodValue);\n        const maxBondQuote = await bondContract.payoutFor(maxValuation);\n        maxBondPriceToken = maxBondPrice / (maxBondQuote * Math.pow(10, -9));\n    } else {\n        bondQuote = await bondContract.payoutFor(amountInWei);\n        bondQuote = bondQuote / Math.pow(10, 18);\n\n        const maxBondQuote = await bondContract.payoutFor(maxBodValue);\n        maxBondPriceToken = maxBondPrice / (maxBondQuote * Math.pow(10, -18));\n    }\n\n    if (!!value && bondQuote > maxBondPrice) {\n        dispatch(error({ text: messages.try_mint_more(maxBondPrice.toFixed(2).toString()) }));\n    }\n\n    // Calculate bonds purchased\n    const token = bond.getContractForReserve(networkID, provider);\n    let purchased = await token.balanceOf(addresses.TREASURY_ADDRESS);\n\n    if (bond.isLP) {\n        const assetAddress = bond.getAddressForReserve(networkID);\n        const markdown = await bondCalcContract.markdown(assetAddress);\n\n        purchased = await bondCalcContract.valuation(assetAddress, purchased);\n        purchased = (markdown / Math.pow(10, 18)) * (purchased / Math.pow(10, 9));\n\n        if (bond.name === avaxSb.name) {\n            const avaxPrice = getTokenPrice(\"AVAX\");\n            purchased = purchased * avaxPrice;\n        }\n    } else if (bond.name === wavax.name) {\n        purchased = purchased / Math.pow(10, 18);\n        const avaxPrice = getTokenPrice(\"AVAX\");\n        purchased = purchased * avaxPrice;\n    } else {\n        purchased = purchased / Math.pow(10, 18);\n    }\n\n    return {\n        bond: bond.name,\n        bondDiscount,\n        bondQuote,\n        purchased,\n        vestingTerm: Number(terms.vestingTerm),\n        maxBondPrice,\n        bondPrice: bondPrice / Math.pow(10, 18),\n        marketPrice,\n        maxBondPriceToken,\n    };\n});\n\ninterface IBondAsset {\n    value: string;\n    address: string;\n    bond: Bond;\n    networkID: Networks;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    slippage: number;\n    useAvax: boolean;\n}\nexport const bondAsset = createAsyncThunk(\"bonding/bondAsset\", async ({ value, address, bond, networkID, provider, slippage, useAvax }: IBondAsset, { dispatch }) => {\n    const depositorAddress = address;\n    const acceptedSlippage = slippage / 100 || 0.005;\n    const valueInWei = ethers.utils.parseUnits(value, \"ether\");\n    const signer = provider.getSigner();\n    const bondContract = bond.getContractForBond(networkID, signer);\n\n    const calculatePremium = await bondContract.bondPrice();\n    const maxPremium = Math.round(calculatePremium * (1 + acceptedSlippage));\n\n    let bondTx;\n    try {\n        const gasPrice = await getGasPrice(provider);\n\n        if (useAvax) {\n            bondTx = await bondContract.deposit(valueInWei, maxPremium, depositorAddress, { value: valueInWei, gasPrice });\n        } else {\n            bondTx = await bondContract.deposit(valueInWei, maxPremium, depositorAddress, { gasPrice });\n        }\n        dispatch(\n            fetchPendingTxns({\n                txnHash: bondTx.hash,\n                text: i18n.t(\"bond:BondingBond\", { bond: bond.displayName }),\n                type: \"bond_\" + bond.name,\n            }),\n        );\n        await bondTx.wait();\n        dispatch(success({ text: messages.tx_successfully_send }));\n        dispatch(info({ text: messages.your_balance_update_soon }));\n        await sleep(10);\n        await dispatch(calculateUserBondDetails({ address, bond, networkID, provider }));\n        dispatch(info({ text: messages.your_balance_updated }));\n        return;\n    } catch (err: any) {\n        return metamaskErrorWrap(err, dispatch);\n    } finally {\n        if (bondTx) {\n            dispatch(clearPendingTxn(bondTx.hash));\n        }\n    }\n});\n\ninterface IRedeemBond {\n    address: string;\n    bond: Bond;\n    networkID: Networks;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    autostake: boolean;\n}\n\nexport const redeemBond = createAsyncThunk(\"bonding/redeemBond\", async ({ address, bond, networkID, provider, autostake }: IRedeemBond, { dispatch }) => {\n    if (!provider) {\n        dispatch(warning({ text: messages.please_connect_wallet }));\n        return;\n    }\n\n    const signer = provider.getSigner();\n    const bondContract = bond.getContractForBond(networkID, signer);\n\n    let redeemTx;\n    try {\n        const gasPrice = await getGasPrice(provider);\n\n        redeemTx = await bondContract.redeem(address, autostake === true, { gasPrice });\n        const pendingTxnType = \"redeem_bond_\" + bond.name + (autostake === true ? \"_autostake\" : \"\");\n        dispatch(\n            fetchPendingTxns({\n                txnHash: redeemTx.hash,\n                text: i18n.t(\"bond:RedeemingBond\", { bond: bond.displayName }),\n                type: pendingTxnType,\n            }),\n        );\n        await redeemTx.wait();\n        dispatch(success({ text: messages.tx_successfully_send }));\n        await sleep(0.01);\n        dispatch(info({ text: messages.your_balance_update_soon }));\n        await sleep(10);\n        await dispatch(calculateUserBondDetails({ address, bond, networkID, provider }));\n        await dispatch(getBalances({ address, networkID, provider }));\n        dispatch(info({ text: messages.your_balance_updated }));\n        return;\n    } catch (err: any) {\n        metamaskErrorWrap(err, dispatch);\n    } finally {\n        if (redeemTx) {\n            dispatch(clearPendingTxn(redeemTx.hash));\n        }\n    }\n});\n\nexport interface IBondSlice {\n    loading: boolean;\n    [key: string]: any;\n}\n\nconst initialState: IBondSlice = {\n    loading: true,\n};\n\nconst setBondState = (state: IBondSlice, payload: any) => {\n    const bond = payload.bond;\n    const newState = { ...state[bond], ...payload };\n    state[bond] = newState;\n    state.loading = false;\n};\n\nconst bondingSlice = createSlice({\n    name: \"bonding\",\n    initialState,\n    reducers: {\n        fetchBondSuccess(state, action) {\n            state[action.payload.bond] = action.payload;\n        },\n    },\n    extraReducers: builder => {\n        builder\n            .addCase(calcBondDetails.pending, state => {\n                state.loading = true;\n            })\n            .addCase(calcBondDetails.fulfilled, (state, action) => {\n                setBondState(state, action.payload);\n                state.loading = false;\n            })\n            .addCase(calcBondDetails.rejected, (state, { error }) => {\n                state.loading = false;\n                console.log(error);\n            });\n    },\n});\n\nexport default bondingSlice.reducer;\n\nexport const { fetchBondSuccess } = bondingSlice.actions;\n\nconst baseInfo = (state: RootState) => state.bonding;\n\nexport const getBondingState = createSelector(baseInfo, bonding => bonding);\n"]},"metadata":{},"sourceType":"module"}