{"ast":null,"code":"import { Bond } from \"./bond\";\nimport { BondType } from \"./constants\";\nimport { getBondCalculator } from \"../bond-calculator\";\nimport { getAddresses } from \"../../constants/addresses\"; // Keep all LP specific fields/logic within the LPBond class\n\nexport class LPBond extends Bond {\n  constructor(lpBondOpts) {\n    super(BondType.LP, lpBondOpts);\n    this.isLP = true;\n    this.lpUrl = void 0;\n    this.reserveContractAbi = void 0;\n    this.displayUnits = void 0;\n    this.lpUrl = lpBondOpts.lpUrl;\n    this.reserveContractAbi = lpBondOpts.reserveContractAbi;\n    this.displayUnits = \"LP\";\n  }\n\n  async getTreasuryBalance(networkID, provider) {\n    const addresses = getAddresses(networkID);\n    const token = this.getContractForReserve(networkID, provider);\n    const tokenAddress = this.getAddressForReserve(networkID);\n    const bondCalculator = getBondCalculator(networkID, provider);\n    const tokenAmount = await token.balanceOf(addresses.TREASURY_ADDRESS);\n    const valuation = await bondCalculator.valuation(tokenAddress, tokenAmount);\n    const markdown = await bondCalculator.markdown(tokenAddress);\n    const tokenUSD = valuation / Math.pow(10, 9) * (markdown / Math.pow(10, 18));\n    return tokenUSD;\n  }\n\n  getTokenAmount(networkID, provider) {\n    return this.getReserves(networkID, provider, true);\n  }\n\n  getSbAmount(networkID, provider) {\n    return this.getReserves(networkID, provider, false);\n  }\n\n  async getReserves(networkID, provider, isToken) {\n    const addresses = getAddresses(networkID);\n    const token = this.getContractForReserve(networkID, provider);\n    let [reserve0, reserve1] = await token.getReserves();\n    const token1 = await token.token1();\n    const isSb = token1.toLowerCase() === addresses.SB_ADDRESS.toLowerCase();\n    return isToken ? this.toTokenDecimal(false, isSb ? reserve0 : reserve1) : this.toTokenDecimal(true, isSb ? reserve1 : reserve0);\n  }\n\n  toTokenDecimal(isSb, reserve) {\n    return isSb ? reserve / Math.pow(10, 9) : reserve / Math.pow(10, 18);\n  }\n\n} // These are special bonds that have different valuation methods\n\nexport class CustomLPBond extends LPBond {\n  constructor(customBondOpts) {\n    super(customBondOpts);\n\n    this.getTreasuryBalance = async (networkID, provider) => {\n      const tokenAmount = await super.getTreasuryBalance(networkID, provider);\n      const tokenPrice = this.getTokenPrice();\n      return tokenAmount * tokenPrice;\n    };\n\n    this.getTokenAmount = async (networkID, provider) => {\n      const tokenAmount = await super.getTokenAmount(networkID, provider);\n      const tokenPrice = this.getTokenPrice();\n      return tokenAmount * tokenPrice;\n    };\n  }\n\n}","map":{"version":3,"sources":["/Users/anthonymann/Desktop/Snowbank DAO/snowbank-frontend/src/helpers/bond/lp-bond.ts"],"names":["Bond","BondType","getBondCalculator","getAddresses","LPBond","constructor","lpBondOpts","LP","isLP","lpUrl","reserveContractAbi","displayUnits","getTreasuryBalance","networkID","provider","addresses","token","getContractForReserve","tokenAddress","getAddressForReserve","bondCalculator","tokenAmount","balanceOf","TREASURY_ADDRESS","valuation","markdown","tokenUSD","Math","pow","getTokenAmount","getReserves","getSbAmount","isToken","reserve0","reserve1","token1","isSb","toLowerCase","SB_ADDRESS","toTokenDecimal","reserve","CustomLPBond","customBondOpts","tokenPrice","getTokenPrice"],"mappings":"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","sourcesContent":["import { ContractInterface } from \"ethers\";\nimport { Bond, BondOpts } from \"./bond\";\nimport { BondType } from \"./constants\";\nimport { Networks } from \"../../constants/blockchain\";\nimport { StaticJsonRpcProvider } from \"@ethersproject/providers\";\nimport { getBondCalculator } from \"../bond-calculator\";\nimport { getAddresses } from \"../../constants/addresses\";\n\n// Keep all LP specific fields/logic within the LPBond class\nexport interface LPBondOpts extends BondOpts {\n    readonly reserveContractAbi: ContractInterface;\n    readonly lpUrl: string;\n}\n\nexport class LPBond extends Bond {\n    readonly isLP = true;\n    readonly lpUrl: string;\n    readonly reserveContractAbi: ContractInterface;\n    readonly displayUnits: string;\n\n    constructor(lpBondOpts: LPBondOpts) {\n        super(BondType.LP, lpBondOpts);\n\n        this.lpUrl = lpBondOpts.lpUrl;\n        this.reserveContractAbi = lpBondOpts.reserveContractAbi;\n        this.displayUnits = \"LP\";\n    }\n\n    async getTreasuryBalance(networkID: Networks, provider: StaticJsonRpcProvider) {\n        const addresses = getAddresses(networkID);\n\n        const token = this.getContractForReserve(networkID, provider);\n        const tokenAddress = this.getAddressForReserve(networkID);\n        const bondCalculator = getBondCalculator(networkID, provider);\n        const tokenAmount = await token.balanceOf(addresses.TREASURY_ADDRESS);\n        const valuation = await bondCalculator.valuation(tokenAddress, tokenAmount);\n        const markdown = await bondCalculator.markdown(tokenAddress);\n        const tokenUSD = (valuation / Math.pow(10, 9)) * (markdown / Math.pow(10, 18));\n\n        return tokenUSD;\n    }\n\n    public getTokenAmount(networkID: Networks, provider: StaticJsonRpcProvider) {\n        return this.getReserves(networkID, provider, true);\n    }\n\n    public getSbAmount(networkID: Networks, provider: StaticJsonRpcProvider) {\n        return this.getReserves(networkID, provider, false);\n    }\n\n    private async getReserves(networkID: Networks, provider: StaticJsonRpcProvider, isToken: boolean): Promise<number> {\n        const addresses = getAddresses(networkID);\n\n        const token = this.getContractForReserve(networkID, provider);\n\n        let [reserve0, reserve1] = await token.getReserves();\n        const token1: string = await token.token1();\n        const isSb = token1.toLowerCase() === addresses.SB_ADDRESS.toLowerCase();\n\n        return isToken ? this.toTokenDecimal(false, isSb ? reserve0 : reserve1) : this.toTokenDecimal(true, isSb ? reserve1 : reserve0);\n    }\n\n    private toTokenDecimal(isSb: boolean, reserve: number) {\n        return isSb ? reserve / Math.pow(10, 9) : reserve / Math.pow(10, 18);\n    }\n}\n\n// These are special bonds that have different valuation methods\nexport interface CustomLPBondOpts extends LPBondOpts {}\n\nexport class CustomLPBond extends LPBond {\n    constructor(customBondOpts: CustomLPBondOpts) {\n        super(customBondOpts);\n\n        this.getTreasuryBalance = async (networkID: Networks, provider: StaticJsonRpcProvider) => {\n            const tokenAmount = await super.getTreasuryBalance(networkID, provider);\n            const tokenPrice = this.getTokenPrice();\n\n            return tokenAmount * tokenPrice;\n        };\n\n        this.getTokenAmount = async (networkID: Networks, provider: StaticJsonRpcProvider) => {\n            const tokenAmount = await super.getTokenAmount(networkID, provider);\n            const tokenPrice = this.getTokenPrice();\n\n            return tokenAmount * tokenPrice;\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}