{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { getAddresses } from \"../../constants\";\nimport { TimeTokenContract, MemoTokenContract, MimTokenContract } from \"../../abi\";\nimport { setAll } from \"../../helpers\";\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nexport const getBalances = createAsyncThunk(\"account/getBalances\", async _ref => {\n  let {\n    address,\n    networkID,\n    provider\n  } = _ref;\n  const addresses = getAddresses(networkID);\n  const ssbContract = new ethers.Contract(addresses.SSB_ADDRESS, MemoTokenContract, provider);\n  const wssbContract = new ethers.Contract(addresses.WSSB_ADDRESS, MemoTokenContract, provider);\n  const ssbBalance = await ssbContract.balanceOf(address);\n  const wssbBalance = await wssbContract.balanceOf(address);\n  const sbContract = new ethers.Contract(addresses.SB_ADDRESS, TimeTokenContract, provider);\n  const sbBalance = await sbContract.balanceOf(address);\n  return {\n    balances: {\n      wssb: ethers.utils.formatUnits(wssbBalance, \"gwei\"),\n      ssb: ethers.utils.formatUnits(ssbBalance, \"gwei\"),\n      sb: ethers.utils.formatUnits(sbBalance, \"gwei\")\n    }\n  };\n});\nexport const loadAccountDetails = createAsyncThunk(\"account/loadAccountDetails\", async _ref2 => {\n  let {\n    networkID,\n    provider,\n    address\n  } = _ref2;\n  let sbBalance = 0;\n  let ssbBalance = 0;\n  let wssbBalance = 0;\n  let stakeAllowance = 0;\n  let unstakeAllowance = 0;\n  let redeemAllowance = 0;\n  const addresses = getAddresses(networkID);\n\n  if (addresses.SB_ADDRESS) {\n    const sbContract = new ethers.Contract(addresses.SB_ADDRESS, TimeTokenContract, provider);\n    sbBalance = await sbContract.balanceOf(address);\n    stakeAllowance = await sbContract.allowance(address, addresses.STAKING_HELPER_ADDRESS);\n    redeemAllowance = await sbContract.allowance(address, addresses.REDEEM_ADDRESS);\n  }\n\n  if (addresses.SSB_ADDRESS) {\n    const ssbContract = new ethers.Contract(addresses.SSB_ADDRESS, MemoTokenContract, provider);\n    ssbBalance = await ssbContract.balanceOf(address);\n    unstakeAllowance = await ssbContract.allowance(address, addresses.STAKING_ADDRESS);\n  }\n\n  if (addresses.WSSB_ADDRESS) {\n    const wssbContract = new ethers.Contract(addresses.WSSB_ADDRESS, MemoTokenContract, provider);\n    wssbBalance = await wssbContract.balanceOf(address);\n  }\n\n  return {\n    balances: {\n      wssb: ethers.utils.formatEther(wssbBalance),\n      ssb: ethers.utils.formatUnits(ssbBalance, \"gwei\"),\n      sb: ethers.utils.formatUnits(sbBalance, \"gwei\")\n    },\n    redeeming: {\n      sb: Number(redeemAllowance)\n    },\n    staking: {\n      sb: Number(stakeAllowance),\n      ssb: Number(unstakeAllowance)\n    }\n  };\n});\nexport const calculateUserBondDetails = createAsyncThunk(\"account/calculateUserBondDetails\", async _ref3 => {\n  let {\n    address,\n    bond,\n    networkID,\n    provider\n  } = _ref3;\n\n  if (!address) {\n    return new Promise(resevle => {\n      resevle({\n        bond: \"\",\n        displayName: \"\",\n        bondIconSvg: \"\",\n        isLP: false,\n        allowance: 0,\n        balance: 0,\n        interestDue: 0,\n        bondMaturationBlock: 0,\n        pendingPayout: \"\",\n        avaxBalance: 0\n      });\n    });\n  }\n\n  const bondContract = bond.getContractForBond(networkID, provider);\n  const reserveContract = bond.getContractForReserve(networkID, provider);\n  let interestDue, pendingPayout, bondMaturationBlock;\n  const bondDetails = await bondContract.bondInfo(address);\n  interestDue = bondDetails.payout / Math.pow(10, 9);\n  bondMaturationBlock = Number(bondDetails.vesting) + Number(bondDetails.lastTime);\n  pendingPayout = await bondContract.pendingPayoutFor(address);\n  let allowance,\n      balance = \"0\";\n  allowance = await reserveContract.allowance(address, bond.getAddressForBond(networkID));\n  balance = await reserveContract.balanceOf(address);\n  const balanceVal = ethers.utils.formatEther(balance);\n  const avaxBalance = await provider.getSigner().getBalance();\n  const avaxVal = ethers.utils.formatEther(avaxBalance);\n  const pendingPayoutVal = ethers.utils.formatUnits(pendingPayout, \"gwei\");\n  return {\n    bond: bond.name,\n    displayName: bond.displayName,\n    bondIconSvg: bond.bondIconSvg,\n    isLP: bond.isLP,\n    allowance: Number(allowance),\n    balance: Number(balanceVal),\n    avaxBalance: Number(avaxVal),\n    interestDue,\n    bondMaturationBlock,\n    pendingPayout: Number(pendingPayoutVal)\n  };\n});\nexport const calculateUserTokenDetails = createAsyncThunk(\"account/calculateUserTokenDetails\", async _ref4 => {\n  let {\n    address,\n    token,\n    networkID,\n    provider\n  } = _ref4;\n\n  if (!address) {\n    return new Promise(resevle => {\n      resevle({\n        token: \"\",\n        address: \"\",\n        img: \"\",\n        allowance: 0,\n        balance: 0\n      });\n    });\n  }\n\n  if (token.isAvax) {\n    const avaxBalance = await provider.getSigner().getBalance();\n    const avaxVal = ethers.utils.formatEther(avaxBalance);\n    return {\n      token: token.name,\n      tokenIcon: token.img,\n      balance: Number(avaxVal),\n      isAvax: true\n    };\n  }\n\n  const addresses = getAddresses(networkID);\n  const tokenContract = new ethers.Contract(token.address, MimTokenContract, provider);\n  let allowance,\n      balance = \"0\";\n  allowance = await tokenContract.allowance(address, addresses.ZAPIN_ADDRESS);\n  balance = await tokenContract.balanceOf(address);\n  const balanceVal = Number(balance) / Math.pow(10, token.decimals);\n  return {\n    token: token.name,\n    address: token.address,\n    img: token.img,\n    allowance: Number(allowance),\n    balance: Number(balanceVal)\n  };\n});\nconst initialState = {\n  loading: true,\n  bonds: {},\n  balances: {\n    wssb: \"\",\n    ssb: \"\",\n    sb: \"\"\n  },\n  staking: {\n    sb: 0,\n    ssb: 0\n  },\n  redeeming: {\n    sb: 0\n  },\n  tokens: {}\n};\nconst accountSlice = createSlice({\n  name: \"account\",\n  initialState,\n  reducers: {\n    fetchAccountSuccess(state, action) {\n      setAll(state, action.payload);\n    }\n\n  },\n  extraReducers: builder => {\n    builder.addCase(loadAccountDetails.pending, state => {\n      state.loading = true;\n    }).addCase(loadAccountDetails.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(loadAccountDetails.rejected, (state, _ref5) => {\n      let {\n        error\n      } = _ref5;\n      state.loading = false;\n      console.log(error);\n    }).addCase(getBalances.pending, state => {\n      state.loading = true;\n    }).addCase(getBalances.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(getBalances.rejected, (state, _ref6) => {\n      let {\n        error\n      } = _ref6;\n      state.loading = false;\n      console.log(error);\n    }).addCase(calculateUserBondDetails.pending, (state, action) => {\n      state.loading = true;\n    }).addCase(calculateUserBondDetails.fulfilled, (state, action) => {\n      if (!action.payload) return;\n      const bond = action.payload.bond;\n      state.bonds[bond] = action.payload;\n      state.loading = false;\n    }).addCase(calculateUserBondDetails.rejected, (state, _ref7) => {\n      let {\n        error\n      } = _ref7;\n      state.loading = false;\n      console.log(error);\n    }).addCase(calculateUserTokenDetails.pending, (state, action) => {\n      state.loading = true;\n    }).addCase(calculateUserTokenDetails.fulfilled, (state, action) => {\n      if (!action.payload) return;\n      const token = action.payload.token;\n      state.tokens[token] = action.payload;\n      state.loading = false;\n    }).addCase(calculateUserTokenDetails.rejected, (state, _ref8) => {\n      let {\n        error\n      } = _ref8;\n      state.loading = false;\n      console.log(error);\n    });\n  }\n});\nexport default accountSlice.reducer;\nexport const {\n  fetchAccountSuccess\n} = accountSlice.actions;\n\nconst baseInfo = state => state.account;\n\nexport const getAccountState = createSelector(baseInfo, account => account);","map":{"version":3,"sources":["/Users/anthonymann/Desktop/Snowbank DAO/snowbank-frontend/src/store/slices/account-slice.ts"],"names":["ethers","getAddresses","TimeTokenContract","MemoTokenContract","MimTokenContract","setAll","createSlice","createSelector","createAsyncThunk","getBalances","address","networkID","provider","addresses","ssbContract","Contract","SSB_ADDRESS","wssbContract","WSSB_ADDRESS","ssbBalance","balanceOf","wssbBalance","sbContract","SB_ADDRESS","sbBalance","balances","wssb","utils","formatUnits","ssb","sb","loadAccountDetails","stakeAllowance","unstakeAllowance","redeemAllowance","allowance","STAKING_HELPER_ADDRESS","REDEEM_ADDRESS","STAKING_ADDRESS","formatEther","redeeming","Number","staking","calculateUserBondDetails","bond","Promise","resevle","displayName","bondIconSvg","isLP","balance","interestDue","bondMaturationBlock","pendingPayout","avaxBalance","bondContract","getContractForBond","reserveContract","getContractForReserve","bondDetails","bondInfo","payout","Math","pow","vesting","lastTime","pendingPayoutFor","getAddressForBond","balanceVal","getSigner","getBalance","avaxVal","pendingPayoutVal","name","calculateUserTokenDetails","token","img","isAvax","tokenIcon","tokenContract","ZAPIN_ADDRESS","decimals","initialState","loading","bonds","tokens","accountSlice","reducers","fetchAccountSuccess","state","action","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","error","console","log","reducer","actions","baseInfo","account","getAccountState"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { getAddresses } from \"../../constants\";\nimport { TimeTokenContract, MemoTokenContract, MimTokenContract } from \"../../abi\";\nimport { setAll } from \"../../helpers\";\n\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { JsonRpcProvider, StaticJsonRpcProvider } from \"@ethersproject/providers\";\nimport { Bond } from \"../../helpers/bond/bond\";\nimport { Networks } from \"../../constants/blockchain\";\nimport React from \"react\";\nimport { RootState } from \"../store\";\nimport { IToken } from \"../../helpers/tokens\";\n\ninterface IGetBalances {\n    address: string;\n    networkID: Networks;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n}\n\ninterface IAccountBalances {\n    balances: {\n        wssb: string;\n        ssb: string;\n        sb: string;\n    };\n}\n\nexport const getBalances = createAsyncThunk(\"account/getBalances\", async ({ address, networkID, provider }: IGetBalances): Promise<IAccountBalances> => {\n    const addresses = getAddresses(networkID);\n\n    const ssbContract = new ethers.Contract(addresses.SSB_ADDRESS, MemoTokenContract, provider);\n    const wssbContract = new ethers.Contract(addresses.WSSB_ADDRESS, MemoTokenContract, provider);\n    const ssbBalance = await ssbContract.balanceOf(address);\n    const wssbBalance = await wssbContract.balanceOf(address);\n    const sbContract = new ethers.Contract(addresses.SB_ADDRESS, TimeTokenContract, provider);\n    const sbBalance = await sbContract.balanceOf(address);\n\n    return {\n        balances: {\n            wssb: ethers.utils.formatUnits(wssbBalance, \"gwei\"),\n            ssb: ethers.utils.formatUnits(ssbBalance, \"gwei\"),\n            sb: ethers.utils.formatUnits(sbBalance, \"gwei\"),\n        },\n    };\n});\n\ninterface ILoadAccountDetails {\n    address: string;\n    networkID: Networks;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n}\n\ninterface IUserAccountDetails {\n    balances: {\n        sb: string;\n        ssb: string;\n        wssb: string;\n    };\n    redeeming: {\n        sb: number;\n    };\n    staking: {\n        sb: number;\n        ssb: number;\n    };\n}\n\nexport const loadAccountDetails = createAsyncThunk(\"account/loadAccountDetails\", async ({ networkID, provider, address }: ILoadAccountDetails): Promise<IUserAccountDetails> => {\n    let sbBalance = 0;\n    let ssbBalance = 0;\n    let wssbBalance = 0;\n    let stakeAllowance = 0;\n    let unstakeAllowance = 0;\n    let redeemAllowance = 0;\n\n    const addresses = getAddresses(networkID);\n\n    if (addresses.SB_ADDRESS) {\n        const sbContract = new ethers.Contract(addresses.SB_ADDRESS, TimeTokenContract, provider);\n        sbBalance = await sbContract.balanceOf(address);\n        stakeAllowance = await sbContract.allowance(address, addresses.STAKING_HELPER_ADDRESS);\n        redeemAllowance = await sbContract.allowance(address, addresses.REDEEM_ADDRESS);\n    }\n\n    if (addresses.SSB_ADDRESS) {\n        const ssbContract = new ethers.Contract(addresses.SSB_ADDRESS, MemoTokenContract, provider);\n        ssbBalance = await ssbContract.balanceOf(address);\n        unstakeAllowance = await ssbContract.allowance(address, addresses.STAKING_ADDRESS);\n    }\n\n    if (addresses.WSSB_ADDRESS) {\n        const wssbContract = new ethers.Contract(addresses.WSSB_ADDRESS, MemoTokenContract, provider);\n        wssbBalance = await wssbContract.balanceOf(address);\n    }\n\n    return {\n        balances: {\n            wssb: ethers.utils.formatEther(wssbBalance),\n            ssb: ethers.utils.formatUnits(ssbBalance, \"gwei\"),\n            sb: ethers.utils.formatUnits(sbBalance, \"gwei\"),\n        },\n        redeeming: {\n            sb: Number(redeemAllowance),\n        },\n        staking: {\n            sb: Number(stakeAllowance),\n            ssb: Number(unstakeAllowance),\n        },\n    };\n});\n\ninterface ICalcUserBondDetails {\n    address: string;\n    bond: Bond;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    networkID: Networks;\n}\n\nexport interface IUserBondDetails {\n    allowance: number;\n    balance: number;\n    avaxBalance: number;\n    interestDue: number;\n    bondMaturationBlock: number;\n    pendingPayout: number; //Payout formatted in gwei.\n}\n\nexport const calculateUserBondDetails = createAsyncThunk(\"account/calculateUserBondDetails\", async ({ address, bond, networkID, provider }: ICalcUserBondDetails) => {\n    if (!address) {\n        return new Promise<any>(resevle => {\n            resevle({\n                bond: \"\",\n                displayName: \"\",\n                bondIconSvg: \"\",\n                isLP: false,\n                allowance: 0,\n                balance: 0,\n                interestDue: 0,\n                bondMaturationBlock: 0,\n                pendingPayout: \"\",\n                avaxBalance: 0,\n            });\n        });\n    }\n\n    const bondContract = bond.getContractForBond(networkID, provider);\n    const reserveContract = bond.getContractForReserve(networkID, provider);\n\n    let interestDue, pendingPayout, bondMaturationBlock;\n\n    const bondDetails = await bondContract.bondInfo(address);\n    interestDue = bondDetails.payout / Math.pow(10, 9);\n    bondMaturationBlock = Number(bondDetails.vesting) + Number(bondDetails.lastTime);\n    pendingPayout = await bondContract.pendingPayoutFor(address);\n\n    let allowance,\n        balance = \"0\";\n\n    allowance = await reserveContract.allowance(address, bond.getAddressForBond(networkID));\n    balance = await reserveContract.balanceOf(address);\n    const balanceVal = ethers.utils.formatEther(balance);\n\n    const avaxBalance = await provider.getSigner().getBalance();\n    const avaxVal = ethers.utils.formatEther(avaxBalance);\n\n    const pendingPayoutVal = ethers.utils.formatUnits(pendingPayout, \"gwei\");\n\n    return {\n        bond: bond.name,\n        displayName: bond.displayName,\n        bondIconSvg: bond.bondIconSvg,\n        isLP: bond.isLP,\n        allowance: Number(allowance),\n        balance: Number(balanceVal),\n        avaxBalance: Number(avaxVal),\n        interestDue,\n        bondMaturationBlock,\n        pendingPayout: Number(pendingPayoutVal),\n    };\n});\n\ninterface ICalcUserTokenDetails {\n    address: string;\n    token: IToken;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    networkID: Networks;\n}\n\nexport interface IUserTokenDetails {\n    allowance: number;\n    balance: number;\n    isAvax?: boolean;\n}\n\nexport const calculateUserTokenDetails = createAsyncThunk(\"account/calculateUserTokenDetails\", async ({ address, token, networkID, provider }: ICalcUserTokenDetails) => {\n    if (!address) {\n        return new Promise<any>(resevle => {\n            resevle({\n                token: \"\",\n                address: \"\",\n                img: \"\",\n                allowance: 0,\n                balance: 0,\n            });\n        });\n    }\n\n    if (token.isAvax) {\n        const avaxBalance = await provider.getSigner().getBalance();\n        const avaxVal = ethers.utils.formatEther(avaxBalance);\n\n        return {\n            token: token.name,\n            tokenIcon: token.img,\n            balance: Number(avaxVal),\n            isAvax: true,\n        };\n    }\n\n    const addresses = getAddresses(networkID);\n\n    const tokenContract = new ethers.Contract(token.address, MimTokenContract, provider);\n\n    let allowance,\n        balance = \"0\";\n\n    allowance = await tokenContract.allowance(address, addresses.ZAPIN_ADDRESS);\n    balance = await tokenContract.balanceOf(address);\n\n    const balanceVal = Number(balance) / Math.pow(10, token.decimals);\n\n    return {\n        token: token.name,\n        address: token.address,\n        img: token.img,\n        allowance: Number(allowance),\n        balance: Number(balanceVal),\n    };\n});\n\nexport interface IAccountSlice {\n    bonds: { [key: string]: IUserBondDetails };\n    balances: {\n        wssb: string;\n        ssb: string;\n        sb: string;\n    };\n    loading: boolean;\n    redeeming: {\n        sb: number;\n    };\n    staking: {\n        sb: number;\n        ssb: number;\n    };\n    tokens: { [key: string]: IUserTokenDetails };\n}\n\nconst initialState: IAccountSlice = {\n    loading: true,\n    bonds: {},\n    balances: { wssb: \"\", ssb: \"\", sb: \"\" },\n    staking: { sb: 0, ssb: 0 },\n    redeeming: { sb: 0 },\n    tokens: {},\n};\n\nconst accountSlice = createSlice({\n    name: \"account\",\n    initialState,\n    reducers: {\n        fetchAccountSuccess(state, action) {\n            setAll(state, action.payload);\n        },\n    },\n    extraReducers: builder => {\n        builder\n            .addCase(loadAccountDetails.pending, state => {\n                state.loading = true;\n            })\n            .addCase(loadAccountDetails.fulfilled, (state, action) => {\n                setAll(state, action.payload);\n                state.loading = false;\n            })\n            .addCase(loadAccountDetails.rejected, (state, { error }) => {\n                state.loading = false;\n                console.log(error);\n            })\n            .addCase(getBalances.pending, state => {\n                state.loading = true;\n            })\n            .addCase(getBalances.fulfilled, (state, action) => {\n                setAll(state, action.payload);\n                state.loading = false;\n            })\n            .addCase(getBalances.rejected, (state, { error }) => {\n                state.loading = false;\n                console.log(error);\n            })\n            .addCase(calculateUserBondDetails.pending, (state, action) => {\n                state.loading = true;\n            })\n            .addCase(calculateUserBondDetails.fulfilled, (state, action) => {\n                if (!action.payload) return;\n                const bond = action.payload.bond;\n                state.bonds[bond] = action.payload;\n                state.loading = false;\n            })\n            .addCase(calculateUserBondDetails.rejected, (state, { error }) => {\n                state.loading = false;\n                console.log(error);\n            })\n            .addCase(calculateUserTokenDetails.pending, (state, action) => {\n                state.loading = true;\n            })\n            .addCase(calculateUserTokenDetails.fulfilled, (state, action) => {\n                if (!action.payload) return;\n                const token = action.payload.token;\n                state.tokens[token] = action.payload;\n                state.loading = false;\n            })\n            .addCase(calculateUserTokenDetails.rejected, (state, { error }) => {\n                state.loading = false;\n                console.log(error);\n            });\n    },\n});\n\nexport default accountSlice.reducer;\n\nexport const { fetchAccountSuccess } = accountSlice.actions;\n\nconst baseInfo = (state: RootState) => state.account;\n\nexport const getAccountState = createSelector(baseInfo, account => account);\n"]},"metadata":{},"sourceType":"module"}