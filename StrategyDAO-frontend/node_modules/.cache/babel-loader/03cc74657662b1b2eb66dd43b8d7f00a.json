{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { getAddresses } from \"../../constants\";\nimport { StakingHelperContract, TimeTokenContract, MemoTokenContract, StakingContract, RedeemContract } from \"../../abi\";\nimport { clearPendingTxn, fetchPendingTxns, getStakingTypeText } from \"./pending-txns-slice\";\nimport { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchAccountSuccess, getBalances } from \"./account-slice\";\nimport { warning, success, info } from \"../../store/slices/messages-slice\";\nimport { messages } from \"../../constants/messages\";\nimport { getGasPrice } from \"../../helpers/get-gas-price\";\nimport { metamaskErrorWrap } from \"../../helpers/metamask-error-wrap\";\nimport { sleep } from \"../../helpers\";\nimport i18n from \"../../i18n\";\nexport const changeRedeemApproval = createAsyncThunk(\"stake/changeRedeemApproval\", async (_ref, _ref2) => {\n  let {\n    token,\n    provider,\n    address,\n    networkID\n  } = _ref;\n  let {\n    dispatch\n  } = _ref2;\n\n  if (!provider) {\n    dispatch(warning({\n      text: messages.please_connect_wallet\n    }));\n    return;\n  }\n\n  const addresses = getAddresses(networkID);\n  const signer = provider.getSigner();\n  const sbContract = new ethers.Contract(addresses.SB_ADDRESS, TimeTokenContract, signer);\n  let approveTx;\n\n  try {\n    const gasPrice = await getGasPrice(provider);\n\n    if (token === \"sb\") {\n      approveTx = await sbContract.approve(addresses.REDEEM_ADDRESS, ethers.constants.MaxUint256, {\n        gasPrice\n      });\n    }\n\n    const text = i18n.t(\"redeem:ApproveStaking\");\n    const pendingTxnType = \"approve_redeem\";\n    dispatch(fetchPendingTxns({\n      txnHash: approveTx.hash,\n      text,\n      type: pendingTxnType\n    }));\n    await approveTx.wait();\n    dispatch(success({\n      text: messages.tx_successfully_send\n    }));\n  } catch (err) {\n    return metamaskErrorWrap(err, dispatch);\n  } finally {\n    if (approveTx) {\n      dispatch(clearPendingTxn(approveTx.hash));\n    }\n  }\n\n  await sleep(2);\n  const stakeAllowance = await sbContract.allowance(address, addresses.STAKING_HELPER_ADDRESS);\n  return dispatch(fetchAccountSuccess({\n    redeeming: {\n      sbStake: Number(stakeAllowance)\n    }\n  }));\n});\nexport const changeApproval = createAsyncThunk(\"stake/changeApproval\", async (_ref3, _ref4) => {\n  let {\n    token,\n    provider,\n    address,\n    networkID\n  } = _ref3;\n  let {\n    dispatch\n  } = _ref4;\n\n  if (!provider) {\n    dispatch(warning({\n      text: messages.please_connect_wallet\n    }));\n    return;\n  }\n\n  const addresses = getAddresses(networkID);\n  const signer = provider.getSigner();\n  const sbContract = new ethers.Contract(addresses.SB_ADDRESS, TimeTokenContract, signer);\n  const ssbContract = new ethers.Contract(addresses.SSB_ADDRESS, MemoTokenContract, signer);\n  let approveTx;\n\n  try {\n    const gasPrice = await getGasPrice(provider);\n\n    if (token === \"sb\") {\n      approveTx = await sbContract.approve(addresses.STAKING_HELPER_ADDRESS, ethers.constants.MaxUint256, {\n        gasPrice\n      });\n    }\n\n    if (token === \"ssb\") {\n      approveTx = await ssbContract.approve(addresses.STAKING_ADDRESS, ethers.constants.MaxUint256, {\n        gasPrice\n      });\n    }\n\n    const text = token === \"sb\" ? i18n.t(\"stake:ApproveStaking\") : i18n.t(\"stake:ApproveUnstaking\");\n    const pendingTxnType = token === \"sb\" ? \"approve_staking\" : \"approve_unstaking\";\n    dispatch(fetchPendingTxns({\n      txnHash: approveTx.hash,\n      text,\n      type: pendingTxnType\n    }));\n    await approveTx.wait();\n    dispatch(success({\n      text: messages.tx_successfully_send\n    }));\n  } catch (err) {\n    return metamaskErrorWrap(err, dispatch);\n  } finally {\n    if (approveTx) {\n      dispatch(clearPendingTxn(approveTx.hash));\n    }\n  }\n\n  await sleep(2);\n  const stakeAllowance = await sbContract.allowance(address, addresses.STAKING_HELPER_ADDRESS);\n  const unstakeAllowance = await ssbContract.allowance(address, addresses.STAKING_ADDRESS);\n  return dispatch(fetchAccountSuccess({\n    staking: {\n      sbStake: Number(stakeAllowance),\n      ssbUnstake: Number(unstakeAllowance)\n    }\n  }));\n});\nexport const changeRedeem = createAsyncThunk(\"stake/changeRedeem\", async (_ref5, _ref6) => {\n  let {\n    action,\n    value,\n    provider,\n    address,\n    networkID\n  } = _ref5;\n  let {\n    dispatch\n  } = _ref6;\n\n  if (!provider) {\n    dispatch(warning({\n      text: messages.please_connect_wallet\n    }));\n    return;\n  }\n\n  const addresses = getAddresses(networkID);\n  const signer = provider.getSigner();\n  const redeem = new ethers.Contract(addresses.REDEEM_ADDRESS, RedeemContract, signer);\n  let stakeTx;\n\n  try {\n    const gasPrice = await getGasPrice(provider);\n    stakeTx = await redeem.swap(ethers.utils.parseUnits(value, \"gwei\"), {\n      gasPrice\n    });\n    const pendingTxnType = i18n.t(\"redeem:Redeem\");\n    dispatch(fetchPendingTxns({\n      txnHash: stakeTx.hash,\n      text: getStakingTypeText(action),\n      type: pendingTxnType\n    }));\n    await stakeTx.wait();\n    dispatch(success({\n      text: messages.tx_successfully_send\n    }));\n  } catch (err) {\n    return metamaskErrorWrap(err, dispatch);\n  } finally {\n    if (stakeTx) {\n      dispatch(clearPendingTxn(stakeTx.hash));\n    }\n  }\n\n  dispatch(info({\n    text: messages.your_balance_update_soon\n  }));\n  await sleep(10);\n  await dispatch(getBalances({\n    address,\n    networkID,\n    provider\n  }));\n  dispatch(info({\n    text: messages.your_balance_updated\n  }));\n  return;\n});\nexport const changeStake = createAsyncThunk(\"stake/changeStake\", async (_ref7, _ref8) => {\n  let {\n    action,\n    value,\n    provider,\n    address,\n    networkID\n  } = _ref7;\n  let {\n    dispatch\n  } = _ref8;\n\n  if (!provider) {\n    dispatch(warning({\n      text: messages.please_connect_wallet\n    }));\n    return;\n  }\n\n  const addresses = getAddresses(networkID);\n  const signer = provider.getSigner();\n  const staking = new ethers.Contract(addresses.STAKING_ADDRESS, StakingContract, signer);\n  const stakingHelper = new ethers.Contract(addresses.STAKING_HELPER_ADDRESS, StakingHelperContract, signer);\n  let stakeTx;\n\n  try {\n    const gasPrice = await getGasPrice(provider);\n\n    if (action === \"stake\") {\n      stakeTx = await stakingHelper.stake(ethers.utils.parseUnits(value, \"gwei\"), address, {\n        gasPrice\n      });\n    } else {\n      stakeTx = await staking.unstake(ethers.utils.parseUnits(value, \"gwei\"), true, {\n        gasPrice\n      });\n    }\n\n    const pendingTxnType = action === \"stake\" ? i18n.t(\"stake:Staking\") : i18n.t(\"stake:Unstaking\");\n    dispatch(fetchPendingTxns({\n      txnHash: stakeTx.hash,\n      text: getStakingTypeText(action),\n      type: pendingTxnType\n    }));\n    await stakeTx.wait();\n    dispatch(success({\n      text: messages.tx_successfully_send\n    }));\n  } catch (err) {\n    return metamaskErrorWrap(err, dispatch);\n  } finally {\n    if (stakeTx) {\n      dispatch(clearPendingTxn(stakeTx.hash));\n    }\n  }\n\n  dispatch(info({\n    text: messages.your_balance_update_soon\n  }));\n  await sleep(10);\n  await dispatch(getBalances({\n    address,\n    networkID,\n    provider\n  }));\n  dispatch(info({\n    text: messages.your_balance_updated\n  }));\n  return;\n});","map":{"version":3,"sources":["/Users/anthonymann/Desktop/Snowbank DAO/snowbank-frontend/src/store/slices/stake-thunk.ts"],"names":["ethers","getAddresses","StakingHelperContract","TimeTokenContract","MemoTokenContract","StakingContract","RedeemContract","clearPendingTxn","fetchPendingTxns","getStakingTypeText","createAsyncThunk","fetchAccountSuccess","getBalances","warning","success","info","messages","getGasPrice","metamaskErrorWrap","sleep","i18n","changeRedeemApproval","token","provider","address","networkID","dispatch","text","please_connect_wallet","addresses","signer","getSigner","sbContract","Contract","SB_ADDRESS","approveTx","gasPrice","approve","REDEEM_ADDRESS","constants","MaxUint256","t","pendingTxnType","txnHash","hash","type","wait","tx_successfully_send","err","stakeAllowance","allowance","STAKING_HELPER_ADDRESS","redeeming","sbStake","Number","changeApproval","ssbContract","SSB_ADDRESS","STAKING_ADDRESS","unstakeAllowance","staking","ssbUnstake","changeRedeem","action","value","redeem","stakeTx","swap","utils","parseUnits","your_balance_update_soon","your_balance_updated","changeStake","stakingHelper","stake","unstake"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { getAddresses } from \"../../constants\";\nimport { StakingHelperContract, TimeTokenContract, MemoTokenContract, StakingContract, RedeemContract } from \"../../abi\";\nimport { clearPendingTxn, fetchPendingTxns, getStakingTypeText } from \"./pending-txns-slice\";\nimport { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchAccountSuccess, getBalances } from \"./account-slice\";\nimport { JsonRpcProvider, StaticJsonRpcProvider } from \"@ethersproject/providers\";\nimport { Networks } from \"../../constants/blockchain\";\nimport { warning, success, info, error } from \"../../store/slices/messages-slice\";\nimport { messages } from \"../../constants/messages\";\nimport { getGasPrice } from \"../../helpers/get-gas-price\";\nimport { metamaskErrorWrap } from \"../../helpers/metamask-error-wrap\";\nimport { sleep } from \"../../helpers\";\n\nimport i18n from \"../../i18n\";\n\ninterface IChangeRedeemApproval {\n    token: string;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    address: string;\n    networkID: Networks;\n}\n\nexport const changeRedeemApproval = createAsyncThunk(\"stake/changeRedeemApproval\", async ({ token, provider, address, networkID }: IChangeRedeemApproval, { dispatch }) => {\n    if (!provider) {\n        dispatch(warning({ text: messages.please_connect_wallet }));\n        return;\n    }\n    const addresses = getAddresses(networkID);\n\n    const signer = provider.getSigner();\n    const sbContract = new ethers.Contract(addresses.SB_ADDRESS, TimeTokenContract, signer);\n\n    let approveTx;\n    try {\n        const gasPrice = await getGasPrice(provider);\n\n        if (token === \"sb\") {\n            approveTx = await sbContract.approve(addresses.REDEEM_ADDRESS, ethers.constants.MaxUint256, { gasPrice });\n        }\n\n        const text = i18n.t(\"redeem:ApproveStaking\");\n        const pendingTxnType = \"approve_redeem\";\n\n        dispatch(fetchPendingTxns({ txnHash: approveTx.hash, text, type: pendingTxnType }));\n        await approveTx.wait();\n        dispatch(success({ text: messages.tx_successfully_send }));\n    } catch (err: any) {\n        return metamaskErrorWrap(err, dispatch);\n    } finally {\n        if (approveTx) {\n            dispatch(clearPendingTxn(approveTx.hash));\n        }\n    }\n\n    await sleep(2);\n\n    const stakeAllowance = await sbContract.allowance(address, addresses.STAKING_HELPER_ADDRESS);\n\n    return dispatch(\n        fetchAccountSuccess({\n            redeeming: {\n                sbStake: Number(stakeAllowance),\n            },\n        }),\n    );\n});\ninterface IChangeApproval {\n    token: string;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    address: string;\n    networkID: Networks;\n}\n\nexport const changeApproval = createAsyncThunk(\"stake/changeApproval\", async ({ token, provider, address, networkID }: IChangeApproval, { dispatch }) => {\n    if (!provider) {\n        dispatch(warning({ text: messages.please_connect_wallet }));\n        return;\n    }\n    const addresses = getAddresses(networkID);\n\n    const signer = provider.getSigner();\n    const sbContract = new ethers.Contract(addresses.SB_ADDRESS, TimeTokenContract, signer);\n    const ssbContract = new ethers.Contract(addresses.SSB_ADDRESS, MemoTokenContract, signer);\n\n    let approveTx;\n    try {\n        const gasPrice = await getGasPrice(provider);\n\n        if (token === \"sb\") {\n            approveTx = await sbContract.approve(addresses.STAKING_HELPER_ADDRESS, ethers.constants.MaxUint256, { gasPrice });\n        }\n\n        if (token === \"ssb\") {\n            approveTx = await ssbContract.approve(addresses.STAKING_ADDRESS, ethers.constants.MaxUint256, { gasPrice });\n        }\n\n        const text = token === \"sb\" ? i18n.t(\"stake:ApproveStaking\") : i18n.t(\"stake:ApproveUnstaking\");\n        const pendingTxnType = token === \"sb\" ? \"approve_staking\" : \"approve_unstaking\";\n\n        dispatch(fetchPendingTxns({ txnHash: approveTx.hash, text, type: pendingTxnType }));\n        await approveTx.wait();\n        dispatch(success({ text: messages.tx_successfully_send }));\n    } catch (err: any) {\n        return metamaskErrorWrap(err, dispatch);\n    } finally {\n        if (approveTx) {\n            dispatch(clearPendingTxn(approveTx.hash));\n        }\n    }\n\n    await sleep(2);\n\n    const stakeAllowance = await sbContract.allowance(address, addresses.STAKING_HELPER_ADDRESS);\n    const unstakeAllowance = await ssbContract.allowance(address, addresses.STAKING_ADDRESS);\n\n    return dispatch(\n        fetchAccountSuccess({\n            staking: {\n                sbStake: Number(stakeAllowance),\n                ssbUnstake: Number(unstakeAllowance),\n            },\n        }),\n    );\n});\n\ninterface IChangeRedeem {\n    action: string;\n    value: string;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    address: string;\n    networkID: Networks;\n}\n\nexport const changeRedeem = createAsyncThunk(\"stake/changeRedeem\", async ({ action, value, provider, address, networkID }: IChangeRedeem, { dispatch }) => {\n    if (!provider) {\n        dispatch(warning({ text: messages.please_connect_wallet }));\n        return;\n    }\n    const addresses = getAddresses(networkID);\n    const signer = provider.getSigner();\n    const redeem = new ethers.Contract(addresses.REDEEM_ADDRESS, RedeemContract, signer);\n\n    let stakeTx;\n\n    try {\n        const gasPrice = await getGasPrice(provider);\n\n        stakeTx = await redeem.swap(ethers.utils.parseUnits(value, \"gwei\"), { gasPrice });\n        const pendingTxnType = i18n.t(\"redeem:Redeem\");\n        dispatch(fetchPendingTxns({ txnHash: stakeTx.hash, text: getStakingTypeText(action), type: pendingTxnType }));\n        await stakeTx.wait();\n        dispatch(success({ text: messages.tx_successfully_send }));\n    } catch (err: any) {\n        return metamaskErrorWrap(err, dispatch);\n    } finally {\n        if (stakeTx) {\n            dispatch(clearPendingTxn(stakeTx.hash));\n        }\n    }\n    dispatch(info({ text: messages.your_balance_update_soon }));\n    await sleep(10);\n    await dispatch(getBalances({ address, networkID, provider }));\n    dispatch(info({ text: messages.your_balance_updated }));\n    return;\n});\n\ninterface IChangeStake {\n    action: string;\n    value: string;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    address: string;\n    networkID: Networks;\n}\n\nexport const changeStake = createAsyncThunk(\"stake/changeStake\", async ({ action, value, provider, address, networkID }: IChangeStake, { dispatch }) => {\n    if (!provider) {\n        dispatch(warning({ text: messages.please_connect_wallet }));\n        return;\n    }\n    const addresses = getAddresses(networkID);\n    const signer = provider.getSigner();\n    const staking = new ethers.Contract(addresses.STAKING_ADDRESS, StakingContract, signer);\n    const stakingHelper = new ethers.Contract(addresses.STAKING_HELPER_ADDRESS, StakingHelperContract, signer);\n\n    let stakeTx;\n\n    try {\n        const gasPrice = await getGasPrice(provider);\n\n        if (action === \"stake\") {\n            stakeTx = await stakingHelper.stake(ethers.utils.parseUnits(value, \"gwei\"), address, { gasPrice });\n        } else {\n            stakeTx = await staking.unstake(ethers.utils.parseUnits(value, \"gwei\"), true, { gasPrice });\n        }\n        const pendingTxnType = action === \"stake\" ? i18n.t(\"stake:Staking\") : i18n.t(\"stake:Unstaking\");\n        dispatch(fetchPendingTxns({ txnHash: stakeTx.hash, text: getStakingTypeText(action), type: pendingTxnType }));\n        await stakeTx.wait();\n        dispatch(success({ text: messages.tx_successfully_send }));\n    } catch (err: any) {\n        return metamaskErrorWrap(err, dispatch);\n    } finally {\n        if (stakeTx) {\n            dispatch(clearPendingTxn(stakeTx.hash));\n        }\n    }\n    dispatch(info({ text: messages.your_balance_update_soon }));\n    await sleep(10);\n    await dispatch(getBalances({ address, networkID, provider }));\n    dispatch(info({ text: messages.your_balance_updated }));\n    return;\n});\n"]},"metadata":{},"sourceType":"module"}